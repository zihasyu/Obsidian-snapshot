>实现一个有去重功能的备份存储系统，实现上传backup、恢复backup俩个功能。
>具体工作流就是上传一个backup(tar包)，然后对该backup进行chunking，计算指纹->去重->数据持久化，可以先只实现上传这个步骤。系统给出一些衡量指标，比如上传多个backup后总过的logical size， physical size，系统运行时间等等。
>恢复backup的功能优先级低一点，看你时间来弄。

## Backup 类: 
实现备份还原功能。
### 成员变量：

Packer
HuffmanCompressor
ChunkingManager
HashCalculator
Deduplicator
DataPersistor
Metrics
//这些类的实例

### 方法函数：
backup上传备份  restore还原
### Packer类：
打包为.tar及解压
#### 方法函数：
pack打包  unpack结包
### Lz4Compressor类：
压缩解压  lz4
#### 方法函数：
compress压缩  decompress解压 

### ChunkingManager类：
文件分块
- **疑问**：我理解里，最后存的是一整个被打包的文件，这里的分块只是为了算指纹去重，以及还原去重时 方便按照索引表还原。那么，是不是不存在快合成的操作（即在解包时不需要这个类的方法）
#### 方法函数：
chunking分块 
	**多个方法**
	
### HashCalculator类：
算指纹
#### 方法函数：
hash_calc()计算指纹


### Deduplicator类：
#### 成员变量：
map
#### 方法函数：
deduplicator去重  restore还原 //去重索引表放文件开头
- **疑问**：这去重的索引表放哪里比较好？单独一个块太浪费了，放文件开头会不会影响huffman的编码表读取？
### DataPersistor类:
数据持久化
#### 方法函数：
file_save存进硬盘  file_load从硬盘读入数据流
	container很多chunk
### Metrics类:
衡量标准
#### 成员变量：
logical size， physical size，系统运行时间等等
#### 方法函数：
计算系统运行时间get_running_time
设置逻辑大小set_logicalSize
设置物理大小set_physicalSize
打印压缩指标信息print_metrics

![[backup流程图.png]]



![[Pasted image 20240421094607.png]]

