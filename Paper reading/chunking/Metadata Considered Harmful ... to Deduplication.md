
![[Pasted image 20240617012550.png]]
图 3：在 tar 中，标头块的更改会产生许多新的独特块。版本 2 中的 chunk1 和 chunk2 与版本 1 中的 chunk1 和 chunk2 不同，因为 header 块发生了变化。

代码、二进制文件和基于磁盘的备份。然而，tar 决定将元数据和数据以其文件格式放在一起，与重复数据删除存储的交互效果很差。具体来说，我们发现，在存储多个版本源代码的tar文件时，我们只能实现约2倍的重复数据删除率；如果我们简单地连接文件（从而丢弃元数据），我们就能够实现高达 18 倍的重复数据删除率（平均块大小为 8 KB）。 tar 格式显然会干扰重复数据删除。

根本原因是元数据的变化比数据块更频繁：我们发现，即使文件内容保持不变，连续两个版本的 Linux 源代码发行版中同一文件的**修改时间也不同**。通过将更频繁更改的元数据与数据块混合在一起，tar 格式不必要地引入了更多独特的块。

mtar 文件和所有标头块保存到一个临时文件，然后将两者连接起来。我们将元数据块的偏移量存储在 mtar 文件的第一个块中，以便高效访问。为了取回原始 tar 文件，恢复操作会读取第一个块，找到第一个标头块，从第二个块开始读取该文件的所有数据块并将其输出。对每个文件重复此过程，从而重新创建原始 tar 文件。 tar 文件的这种动态重组类似于迁移压缩（）[10]。 mtar 格式以及迁移和恢复操作的说明如图 2 所示。

当 tar 文件包含许多小文件时，mtar 效果最佳，因为元数据与数据更频繁地交错。对于我们评估的源代码发行版来说，这通常是正确的。对于主要包含大文件的 tar 文件，我们预计 mtar 的好处较少。我们通过扩展 GNU tar 版本 1.27.1 来实现 mtar

#### Idea:
在 tar 中，标头块的更改（eg时间）会产生许多新的独特块。ver 2 中的 chunk1 和 chunk2 与ver 1 中的 chunk1 和 chunk2 不同，因为 header 块发生了变化。
	而这些会影响断点的生成，以致于内容上的边界偏移
于是本文把所有的**header块**移到了尾部，**内容数据块**放在前面，以及最头部放一个索引块来指定第一个header（用于恢复）。
//**为便于理解，图里512B为单位tar块叫数据块，基于断点分的叫chunk**
	但他还是没能把chunk和块结合起来，感觉效果上不如我们的做法，他这样做在尾部还是会受到一些边界偏移的影响，而用header块的metadata去指导chunking过程，使得chunk一定是512B的倍数，能更好地避免因部分内容修改导致的**断点消失或提前**

#### Design
代码、二进制文件和基于磁盘的备份。然而，tar 决定将元数据和数据以其文件格式放在一起，与重复数据删除存储的交互效果很差。具体来说，我们发现，在存储多个版本源代码的tar文件时，我们只能实现约2倍的重复数据删除率；如果我们简单地连接文件（从而丢弃元数据），我们就能够实现高达 18 倍的重复数据删除率（平均块大小为 8 KB）。 tar 格式显然会干扰重复数据删除。
![[Pasted image 20240617013025.png]]
根本原因是元数据的变化比数据块更频繁：我们发现，即使文件内容保持不变，连续两个版本的 Linux 源代码发行版中同一文件的**修改时间也不同**。通过将更频繁更改的元数据与数据块混合在一起，tar 格式不必要地引入了更多独特的块。
mtar 文件和所有标头块保存到一个临时文件，然后将两者连接起来。我们将元数据块的偏移量存储在 mtar 文件的第一个块中，以便高效访问。为了取回原始 tar 文件，恢复操作会读取第一个块，找到第一个标头块，从第二个块开始读取该文件的所有数据块并将其输出。对每个文件重复此过程，从而重新创建原始 tar 文件。 tar 文件的这种动态重组类似于迁移压缩。 mtar 格式以及迁移和恢复操作的说明如figure 2 所示。
当 tar 文件包含许多小文件时，mtar 效果最佳，因为元数据与数据更频繁地交错。对于我们评估的源代码发行版来说，这通常是正确的。对于主要包含大文件的 tar 文件，我们预计 mtar 的好处较少。