### 计网
#### 传输层 
1. TCP 提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。**如何保证数据无差错、不丢失、不重复且有序的？有哪些机制来保证？**
	TCP 使用了校验、序号、确认和重传等机制来达到这一目的。
2. TCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP 连接的两端都设 有发送缓存和接收缓存，用来临时存放双向通信的数据。**为什么需要设置缓存，缓存的作用？**
	发送缓存用来暂时存放以下数据：1.发送应用程序传送给发送方TCP 准备发送的数据；2.TCP 已发送但尚未收到确认的数据。 
	接收缓存用来暂时存放以下数据：1.按序到达但尚未被接收应用程序读取的数据；2.不按序到达的 数据。
3. TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程 序交下来的数据仅视为一连串的无结构的字节流。
	一个字节占一个序号，每个报文段用第一个字节的序号来标识,例如，一报文段的序号字段值是 301, 而携带的数据共有l00B, 表明本报文段的数据的最后一个字节的序号是400, 因此下一个报文 段的数据序号应从401开始，也就是期望的下一个序号（确认号）。
4. **TCP特点**
	1) TCP 是面向连接的传输层协议。
	2) 每条TCP 连接只能有两个端点，每条TCP 连接只能是点对点的（一对一）。
	3) TCP 提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。
	4) TCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP 连接的两端都设 有发送缓存和接收缓存，用来临时存放双向通信的数据。
	5) TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程 序交下来的数据仅视为一连串的无结构的字节流。
5. TCP报文字段解释
	1) 序号字段（就是seq）：序号字段的值指的是本报文段所发送的数据的第一个字节的序号。 
	2) 确认号字段（就是ack）：是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认 号为N, 则表明到序号N-1为止的所有数据都已正确收到。（累积确认） 
	3) 确认位ACK：只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP 规定，在连 接建立后所有传送的报文段都必须把ACK置1。 
	4) 同步位SYN：同步SYN=1表示这是一个连接请求或连接接收报文。当SYN= 1, ACK=0 时，表明 这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN= 1, ACK=1。即SYN=1 表示这是一个连接请求或连接接收报文。
	5) 终止位FIN (Finish) ：用来释放一个连接。FIN=1表明此报文段的发送方的数据已发送完毕了并 要求释放传输连接。
6. 三次握手
![[Pasted image 20240318193823.png]]
	1) 第一次握手：客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含 应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号seq = x（连接请 求报文不携带数据，但要消耗一个序号）。 
	2) 第二次握手：服务器的TCP 收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该 TCP连接分配TCP缓存和变量。在确认报文段中，SYN 和ACK 位都被置为1, 确认号字段的值为x+1,并且 服务器随机产生起始序号seq= y( 确认报文不携带数据，但也要消耗一个序号）。确认报文段同样不包 含应用层数据。 
	3) 第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变 量。这个报文段的ACK 标志位被置1, 序号字段为x+1, 确认号字段ack=y+1。该报文段可以携带数据，若 不携带数据则不消耗序号 http中的tcp连接的第三次握手的报文段中就捎带了客户对万维网文档的请求 。
	4) 成功进行以上三步后，就建立了TCP 连接，接下来就可以传送应用层数据。TCP 提供的是全双工通信， 因此通信双方的应用进程在任何时候都能发送数据。
	5)【拓展问题3】：为什么不采用“两次握手”建立连接呢？ 答：这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错 误。考虑下面这种情况。客户A 向服务器B 发出TCP 连接请求，第一个连接请求报文在网络的某 个结点长时间滞留， A 超时后认为报文丢失，于是再重传一次连接请求， B 收到后建立连接。数 据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器B, 而B 认为A 又发来连接请求，此时若使用“三次握手”，则B 向A 返回确认报文段，由于是一个失效的请求，因 此A 不予理睬，建立连接失败。若采用的是“两次握手”，则这种情况下B 认为传输连接已经建立， 并一直等待A 传输数据，而A 此时并无连接请求，因此不予理睬，这样就造成了B的资源白白浪 费。
7. 四次挥手
![[Pasted image 20240318193740.png]]
	1) 第一次握手：客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关 闭TCP 连接，该报文段的FIN 标志位被置1, seq= u, 它等于前面已传送过的数据的最后一个字节的序号 加1 (FIN 报文段即使不携带数据，也要消耗一个序号）。TCP是全双工的，即可以想象为一条TCP 连接 上有两条数据通路。发送FIN 报文时，发送FIN 的一端不能再发送数据，即关闭了其中一条数据通路， 但对方还可以发送数据。 
	2) 第二次握手：服务器收到连接释放报文段后即发出确认，确认号是ack = u + 1, 而这个报文段自己的 序号是v, 等千它前面已传送过的数据的最后一个字节的序号加1 。此时，从客户机到服务器这个方向的 连接就释放了，TCP连接处千半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户 机这个方向的连接并未关闭。 
	3) 第三次握手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN=1的 连接释放报文段。 
	4) 第四次握手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1, 确 认号ack= w + 1, 序号seq= u + 1 。此时TCP连接还未释放，必须经过时间等待计时器设置的时间 2MSL（最长报文段寿命）后，A才进入连接关闭状态。
	5) 【拓展问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK 报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。 故需要四次握手。
	//ACK表示应答，SYN，FIN才是连接相关。
	6) 【拓展问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状 态？ 答：1)虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client 发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片 段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进 入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到 FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大 时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束 TCP连接。
	//为了确保ACK被服务器端收到，也就是说服务器端不再发FIN
#### 网络层
路由算法综述：
**路由器转发分组**是通过**路由表**转发的，而路由表是通过各种算法得到的。主机通常直接与一台路由器相 连接，该路由器即为该主机的默认路由器(defaultrouter) ，又称该主机的第一跳路由器(first-hop router)每当主机发送一个分组时，该分组被传送给它的默认路由器。源主机的默认路由器称作源路由器 (sourcerouter) ,目的主机的默认路由器称作目的路由器(destination router)。
	静态路由算法
	动态路由算法：
	**距离-向量路由算法**（RIP 路由信息协议）所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结 点。这种路由选择表包含： 1) 每条路径的目的地（另一结点）。 2) 路径的代价（也称距离）。
	**链路状态路由算法**要求每个参与该算法的结点都具有完全的网络拓扑信息，它们执行下述两项任务: 1) 第一，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链 路，或者连接到同一广播型物理网络。 2) 第二，定期地将链路状态传播给所有其他结点。 典型的链路状态算法是OSPF算法。
#### 数据链路层
局域网的数据链路层分为逻辑链路层LLC和介质访问控制MAC两个子层。逻辑链路控制（Logical Link Control或简称LLC）是局域网中数据链路层的上层部分，IEEE 802.2中定义了逻辑链路控制协议。用户 的数据链路服务通过LLC子层为网络层提供统一的接口。在LLC子层下面是MAC子层。MAC(medium access control)属于LLC（Logical Link Control）下的一个子层，提供介质访问控控制的功能。
1. 为什么需要介质访问控制？ 、
	因为局域网是一种广播式的网络（广域网是一种点对点的网络），所 有联网计算机都共享一个公共信道，所以，需要一种方法能有效地分配传输介质的使用权，使得两 对结点之间的通信不会发生相互干扰的情况，这种功能就叫介质访问控制。
2. 介质访问控制的分类？ 
	 常见的介质访问控制方法有**信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制**。其中前者是静态划分信道的方法，而后两者是动态分配信道的方法。

信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为儿条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。 信道划分介质访问控制分为以下4 种：频分多路复用，时分多路复用（只时间），波分多路复用，码分多路复用（时空都共享）。
3. 随机访问介质访问控制
	常用的协议有ALOHA 协议、CSMA协议、CSMA/CD 协议和CSMA/CA 协议等，它们的核心思想都 是：胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问介质访问控制协议又称争用型 协议。随机介质访问控制实质上是一种将广播信道转化为点到点信道的行为。
4. 轮询访问介质访问控制：令牌传递协议
	在轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个结 点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道。

